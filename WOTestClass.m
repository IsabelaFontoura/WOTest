//
//  WOTestClass.m
//  WOTest
//
//  Created by Wincent Colaiuta on 12 October 2004.
//
//  Copyright 2004-2007 Wincent Colaiuta.
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
//

// class header
#import "WOTestClass.h"

// system headers
#import <objc/objc-runtime.h>
#import <sys/types.h>               /* write() */
#import <sys/uio.h>                 /* write() */
#import <unistd.h>                  /* write(), _exit() */
#import <mach/mach.h>
#import <pthread.h>

// framework headers
#import "WOTest.h"
#import "exc.h"                     /* generated by MiG */

// make what(1) produce meaningful output
#import "WOTest_Version.h"

#define WO_UNICODE_PLUS_MINUS_SIGN  0x00b1
#define WO_UNICODE_ELLIPSIS         0x2026

// convenience macros, call method to truncate description to 64 characters
#define WO_TRUNCATE_INDEX           64

// return truncated description of \p object, expects a BOOL variable of the format objectTruncated to be defined within the same scope
#define WO_DESC(object)             [self description:object truncatedAt:WO_TRUNCATE_INDEX didTruncate:&object ## Truncated]

// return untruncated description of object
#define WO_LONG_DESC(object)        [self description:object truncatedAt:0 didTruncate:NULL]

#define WO_UNCAUGHT_EXCEPTION_ERROR @"uncaught exception"

// convenience macro to throw exception when NSString type checking fails
#define WO_EXPECTED_STRING_EXCEPTION_REASON(object)                         \
[NSString stringWithFormat:@"Expected NSString object but got object of class \"%@\"", NSStringFromClass([object class])]

// convenience macro to throw exception when NSArray type checking fails
#define WO_EXPECTED_ARRAY_EXCEPTION_REASON(object)                          \
[NSString stringWithFormat:@"Expected NSArray object but got object of class \"%@\"", NSStringFromClass([object class])]

// convenience macro to throw exception when NSDictionary type check fails
#define WO_EXPECTED_DICTIONARY_EXCEPTION_REASON(object)                     \
[NSString stringWithFormat:@"Expected NSDictionary object but got object of class \"%@\"", NSStringFromClass([object class])]

#define WO_NIL_PARAMETER_EXCEPTION_REASON @"A test which does not accept nil parameters was passed a nil parameter"

// Return a random offset between 0 and WO_RANDOMIZATION_RANGE inclusive.
#define WO_RANDOM_OFFSET            (random() % (WO_RANDOMIZATION_RANGE - 1))

// Return +1 or -1 randomly.
#define WO_RANDOM_SIGN              ((BOOL)(random() % 2) ? 1 : -1)

#pragma mark -
#pragma mark Class variables

static WOTest                       *WOTestSharedInstance           = nil;
static volatile BOOL                WOTestCanJump                   = NO;
static volatile ExceptionKind       WOLastLowLevelException;
static volatile sig_atomic_t        WOTestExceptionTriggered        = 0;
static ExceptionHandlerUPP          WOOldLowLevelExceptionHandler;

// for the timebeing, only store/restore a limited number of registers; may remove the unused ones from the struct at a later time
typedef struct WOJumpBuffer {
    unsigned long eax;      // store/restore
    unsigned long ebx;      // store/restore
    unsigned long ecx;
    unsigned long edx;
    unsigned long edi;      // store/restore
    unsigned long esi;      // store/restore
    unsigned long ebp;      // store/restore
    unsigned long esp;      // store/restore
    unsigned long ss;
    unsigned long eflags;
    unsigned long cs;
    unsigned long ds;
    unsigned long es;
    unsigned long fs;
    unsigned long gs;
} WOJumpBuffer;
static volatile WOJumpBuffer WOLowLevelExceptionJumpBuffer;

#ifdef __i386__
static unsigned long    WOProgramCounter;
#elif defined (__ppc__)
static UnsignedWide     WOProgramCounter;
#else
#error Unsupported architecture
#endif

#pragma mark -
#pragma mark Functions

OSStatus WOLowLevelExceptionHandler(ExceptionInformation *theException)
{
    if (!WOTestCanJump)         // unexpected exception
    {
        fprintf(stderr, "error: WOTest internal error (unexpected exception in WOLowLevelExceptionHandler)\n");
        fprintf(stderr, "Exception type: %lu\n", (unsigned long)(theException->theKind));
        fflush(NULL);

        // forwarding to old exception handler doesn't seem to work (get into infinite loop)
        //return InvokeExceptionHandlerUPP(theException, WOOldLowLevelExceptionHandler);
        _exit(EXIT_FAILURE);
    }

    WOLastLowLevelException     = theException->theKind;
    WOTestCanJump                       = NO;

    // set flag to indicate that an exception was triggerd
    WOTestExceptionTriggered            = 1;

    // will resume execution at previously marked "safe place": longjmp would be fine here
#ifdef __i386__
    // set only the registers that setjmp() saves and longjmp() restores
    theException->machineState->EIP     = WOProgramCounter;
    theException->registerImage->EBP    = WOLowLevelExceptionJumpBuffer.ebp;
    theException->registerImage->EAX    = WOLowLevelExceptionJumpBuffer.eax;
    theException->registerImage->EBX    = WOLowLevelExceptionJumpBuffer.ebx;
    theException->registerImage->EDI    = WOLowLevelExceptionJumpBuffer.edi;
    theException->registerImage->ESI    = WOLowLevelExceptionJumpBuffer.esi;
    theException->registerImage->ESP    = WOLowLevelExceptionJumpBuffer.esp;

    // clear out exception state (probably not necessary)
    theException->info.memoryInfo       = NULL;

#elif defined (__ppc__)
    theException->machineState->PC      = WOProgramCounter;
    // TODO: must restore more state here
#else
#error Unsupported architecture
#endif
    return noErr;
}

@interface WOTest ()

- (void)installLowLevelExceptionHandler;
- (void)removeLowLevelExceptionHandler;

/*! Check to see that the start date has been recorded. If it has not, record it. */
- (void)checkStartDate;

/*! Helper method for optionally trimming path names before printing them to the console. */
- (NSString *)trimmedPath:(char *)path;

#pragma mark -
#pragma mark Properties

//! \name Properties
//! Public properties previously declared readonly have a private readwrite implementation internally to the class.
//! \startgroup

// NOTE: The documentation would suggest that the repetition of the "copy" attribute here is not required, but without it the
// compiler issues various warnings. A Radar has been filed against this (<rdar://problem/5403996>) as it appears to be either a
// compiler bug or a documentation bug. The corresponding test case can be found in the other/readonly_readwrite_properties_bug
// subdirectory.

@property(readwrite, copy) NSDate   *startDate;
@property(readwrite) unsigned       testsRun;
@property(readwrite) unsigned       testsPassed;
@property(readwrite) unsigned       testsFailed;
@property(readwrite) unsigned       uncaughtExceptions;
@property(readwrite) unsigned       testsFailedExpected;
@property(readwrite) unsigned       testsPassedUnexpected;
@property(readwrite) unsigned       lowLevelExceptionsExpected;
@property(readwrite) unsigned       lowLevelExceptionsUnexpected;
@property(readwrite, copy) NSString *lastReportedFile;
@property(readwrite) int            lastReportedLine;

//! \endgroup

@end

@implementation WOTest

#pragma mark -
#pragma mark Singleton pattern enforcement methods

+ (WOTest *)sharedInstance;
{
    // speed less of a concern here than robustness so always lock (instead of using double-checked locking plus memory barriers)
    volatile id instance = nil;
    @synchronized (WOTestSharedInstance)
    {
        if (WOTestSharedInstance)
            instance = WOTestSharedInstance;
        else
            instance = [[self alloc] init];
    }
    return instance;
}

- (id)init
{
    @synchronized (WOTestSharedInstance)
    {
        if (!WOTestSharedInstance)          // first time here
        {
            if ((self = [super init]))
                // once-off initialization and setting of defaults:
                self->warnsAboutSignComparisons = YES;
            WOTestSharedInstance = self;
        }
        else
            NSDeallocateObject(self);       // were racing, but lost the race
    }
    return WOTestSharedInstance;
}

// overriding allocWithZone also effectively overrides alloc
+ (id)allocWithZone:(NSZone *)aZone
{
    volatile id instance = nil;
    @synchronized (WOTestSharedInstance)
    {
        if (WOTestSharedInstance)
            instance = WOTestSharedInstance;
        else
            instance = NSAllocateObject([self class], 0, aZone);
    }
    return instance;
}

- (oneway void)release
{
    return;
}

- (void)dealloc
{
    [self doesNotRecognizeSelector:_cmd];   // being a singleton, officially does not support dealloc
    [super dealloc];                        // this line necessary to suppress compiler warning
}

- (unsigned)retainCount
{
    return UINT_MAX;
}

- (id)autorelease
{
    return self;
}

- (id)retain
{
    return self;
}

// overriding this also overrides copy
- (id)copyWithZone:(NSZone *)zone
{
    return self;
}

// overriding this also overrides mutableCopy
- (id)mutableCopyWithZone:(NSZone *)zone
{
    return self;
}

#pragma mark -
#pragma mark Utility methods

- (NSString *)description:(id)anObject truncatedAt:(unsigned)index didTruncate:(BOOL *)didTruncate
{
    if (didTruncate)    *didTruncate    = NO;
    NSString            *description    = nil;
    if (!anObject)
        description = @"(nil)";
    else
    {
        @try
        {
            description = [NSObject WOTest_descriptionForObject:anObject];
            unsigned int originalLength = [description length];
            if (index > 0)  // a value of 0 would indicate that no truncation is to be performed
            {
                description = [description WOTest_stringByCollapsingWhitespace];
                if ([description length] > index)
                    description = [[description substringToIndex:index] WOTest_stringByAppendingCharacter:WO_UNICODE_ELLIPSIS];
                if (([description length] != originalLength) && (didTruncate))
                    *didTruncate = YES;
            }
        }
        @catch (id e)
        {
            description = @"(exception caught trying to get object description)";
        }
    }
    return description;
}

- (void)seedRandomNumberGenerator
{
    srandom(time(NULL));
}

- (void)seedRandomNumberGenerator:(unsigned long)seed
{
    srandom(seed);
}

- (BOOL)isClassMethod:(NSString *)method
{
    return (method && [method hasPrefix:@"+"]);
}

- (BOOL)isInstanceMethod:(NSString *)method
{
    return (method && [method hasPrefix:@"-"]);
}

- (SEL)selectorFromMethod:(NSString *)method
{
    NSParameterAssert(method != nil);
    NSParameterAssert([method length] > 1);
    NSString *selectorName = [method substringFromIndex:1];
    return NSSelectorFromString(selectorName);
}

#pragma mark -
#pragma mark Test-running methods

- (void)checkStartDate
{
    @synchronized (self)
    {
        if (self.startDate == nil)
            self.startDate = [NSDate date];
    }
}

- (BOOL)runAllTests
{
    int failures = 0;
    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
    for (NSString *class in [self testableClasses])
        [self runTestsForClassName:class] ? : failures++;
    [self printTestResultsSummary];
    [pool release];
    return (failures > 0) ? NO : YES;
}

- (BOOL)runTestsForClassName:(NSString *)className
{
    NSParameterAssert(className != nil);
    return [self runTestsForClass:NSClassFromString(className)];
}

// all other test-running methods ultimately get funnelled through this method
- (BOOL)runTestsForClass:(Class)aClass
{
    NSParameterAssert(aClass != nil);
    [self checkStartDate];
    BOOL    noTestFailed    = YES;
    NSDate  *startClass     = [NSDate date];
    @try
    {
        _WOLog(@"Running tests for class %@", NSStringFromClass(aClass));
        if ([NSObject WOTest_instancesOfClass:aClass conformToProtocol:@protocol(WOTest)])
        {
            for (NSString *method in [self testableMethodsFrom:aClass])
            {
                NSAutoreleasePool   *pool           = [[NSAutoreleasePool alloc] init];
                NSDate              *startMethod    = [NSDate date];
                SEL                 preflight       = @selector(preflight);
                SEL                 postflight      = @selector(postflight);

                _WOLog(@"Running test method %@", method);
                @try
                {
                    // minimize time spent with exception handlers in place
                    [self installLowLevelExceptionHandler];

                    // record program counter and some other registers right now
#ifdef __i386__
                    // LowLevelABI.pdf says "EDI, ESI, EBX, EBP" are the preserved registers (across function calls)
                    // ebp is the "saved frame pointer": "the base address of the caller's stack frame"
                    // eax is used to return pointer and integral results to callers: "The called function places integral or pointer results in EAX"

                    // info on inline assembly: http://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html
                    __asm__ volatile("movl %%eax, %0\n" : "=m" (WOLowLevelExceptionJumpBuffer.eax));
                    __asm__ volatile("movl %%ebx, %0\n" : "=m" (WOLowLevelExceptionJumpBuffer.ebx));
                    __asm__ volatile("movl %%edi, %0\n" : "=m" (WOLowLevelExceptionJumpBuffer.edi));
                    __asm__ volatile("movl %%esi, %0\n" : "=m" (WOLowLevelExceptionJumpBuffer.esi));
                    __asm__ volatile("movl %%esp, %0\n" : "=m" (WOLowLevelExceptionJumpBuffer.esp));
                    __asm__ volatile("movl %%ebp, %0\n" : "=m" (WOLowLevelExceptionJumpBuffer.ebp));

                    // done this way in Linux (see acpi_save_register_state function)
                    WOProgramCounter = (unsigned long)&&jump_point;
#elif defined (__ppc__)
                    // equivalent to (psuedo code) "WOProgramCounter = current contents of PC register"
                    unsigned long counter;
                    __asm__ volatile("mflr %0" : "=r" (counter));
                    WOProgramCounter.lo = counter & 0xffffffff;
                    WOProgramCounter.hi = (counter & 0xffffffff00000000) >> 32;
#else
#error Unsupported architecture
#endif
                    WOTestCanJump = YES;

                    goto jump_point; // necessary to silence compiler warning about unused label
jump_point:
                    // if flag set, that means we crashed: throw an exception
                    if (WOTestExceptionTriggered)
                    {
                        WOTestExceptionTriggered = 0;
                        @throw [WOTestLowLevelException exceptionWithType:WOLastLowLevelException];
                    }

                    if ([self isClassMethod:method])
                    {
                        if ([NSObject WOTest_class:aClass respondsToSelector:preflight])
                            objc_msgSend(aClass, preflight);
                        objc_msgSend(aClass, [self selectorFromMethod:method]);
                        if ([NSObject WOTest_class:aClass respondsToSelector:postflight])
                            objc_msgSend(aClass, postflight);
                    }
                    else if ([self isInstanceMethod:method])
                    {
                        // class must implement alloc, init and release
                        if ([NSObject WOTest_object:aClass respondsToSelector:@selector(alloc)] &&
                            [NSObject WOTest_instancesOfClass:aClass respondToSelector:@selector(init)] &&
                            [NSObject WOTest_instancesOfClass:aClass respondToSelector:@selector(release)])
                        {
                            id instance = [[aClass alloc] init];
                            if ([NSObject WOTest_instancesOfClass:aClass respondToSelector:preflight])
                                objc_msgSend(instance, preflight);
                            objc_msgSend(instance, [self selectorFromMethod:method]);
                            if ([NSObject WOTest_instancesOfClass:aClass respondToSelector:postflight])
                                objc_msgSend(instance, postflight);
                            [instance release];
                        }
                        else
                        {
                            [self writeError:@"Class %@ must respond to the alloc, init and release selectors",
                                NSStringFromClass(aClass)];
                            [self writeLastKnownLocation];
                        }
                    }
                    else    // should never get here
                        [self writeError:@"WOTest internal error"];
                }
                @catch (WOTestLowLevelException *lowLevelException)
                {
                    if (self.expectLowLevelExceptions)
                    {
                        [self writeStatus:[lowLevelException reason]];    // expected low-level exceptions are not an error
                        self.lowLevelExceptionsExpected++;
                    }
                    else
                    {
                        [self writeError:[lowLevelException reason]];     // unexpected low-level exceptions are an error
                        [self writeLastKnownLocation];
                        noTestFailed = NO;
                        self.lowLevelExceptionsUnexpected++;
                    }
                }
                @catch (id e)
                {
                    [self writeError:@"uncaught exception (%@) in test method %@", [NSException WOTest_descriptionForException:e],
                        method];
                    [self writeLastKnownLocation];
                    noTestFailed = NO;
                    self.uncaughtExceptions++;
                }
                @finally
                {
                    if (lowLevelExceptionHandlerInstalled)
                        [self removeLowLevelExceptionHandler];
                    _WOLog(@"Finished test method %@ (%.4f seconds)", method, -[startMethod timeIntervalSinceNow]);
                    [pool release];
                }
            }
        }
    }
    @catch (id e)
    {
        [self writeError:@"uncaught exception (%@) testing class %@", [NSException WOTest_descriptionForException:e],
            NSStringFromClass(aClass)];
        [self writeLastKnownLocation];
        noTestFailed = NO;
        self.uncaughtExceptions++;
    }
    @finally
    {
        _WOLog(@"Finished tests for class %@ (%.4f seconds)", NSStringFromClass(aClass), -[startClass timeIntervalSinceNow]);
    }
    return noTestFailed;
}

- (NSArray *)testableClasses
{
    // return an array of class names
    NSMutableArray *testableClasses = [NSMutableArray array];

    unsigned    classCount                 = 0; // the total number of classes
    unsigned    conformingClassCount       = 0; // classes conforming to WOTest
    unsigned    nonconformingClassCount    = 0; // unconforming classes
    unsigned    excludedClassCount         = 0; // excluded classes
    unsigned    exceptionCount             = 0; // classes provoking exceptions

    int         numClasses                  = 0;
    int         newNumClasses               = objc_getClassList(NULL, 0);
    Class       *classes                    = NULL;

    // get a list of all classes on the system
    while (numClasses < newNumClasses)
    {
        numClasses          = newNumClasses;
        size_t bufferSize   = sizeof(Class) * numClasses;
        classes             = realloc(classes, bufferSize);
        NSAssert1((classes != NULL), @"realloc() failed (size %d)", bufferSize);
        newNumClasses       = objc_getClassList(classes, numClasses);
    }

    @try
    {
        if (classes)
        {
            // skip over some classes because they not only cause exceptions but also spew out ugly console messages
            SInt32 systemVersion;
            Gestalt(gestaltSystemVersion, &systemVersion);
            systemVersion = systemVersion & 0x0000ffff; // Apple instructs to ignore the high-order word

            NSArray *excludedClasses = (systemVersion < 0x00001040) ?
                [NSArray arrayWithObjects: @"Protocol", @"List", @"Object", @"_NSZombie", nil] :                        // 10.3
                [NSArray arrayWithObjects: @"Protocol", @"List", @"Object", @"_NSZombie", @"NSATSGlyphGenerator", nil]; // 10.4

            if (self.verbosity > 1)
                _WOLog(@"Examining classes for WOTest protocol compliance");

            for (int i = 0; i < newNumClasses; i++)
            {
                classCount++;

                Class       aClass      = classes[i];
                NSString    *className  = NSStringFromClass(aClass);

                @try
                {
                    if ([excludedClasses containsObject:className])
                    {
                        excludedClassCount++;
                        if (self.verbosity > 1)
                            _WOLog(@"Skipping class %@ (appears in exclusion list)", className);
                    }
                    else if ([NSObject WOTest_instancesOfClass:aClass conformToProtocol:@protocol(WOTest)])
                    {
                        conformingClassCount++;
                        [testableClasses addObject:className];
                        if (self.verbosity > 0)
                            _WOLog(@"Class %@ complies with the WOTest protocol", className);
                    }
                    else
                    {
                        nonconformingClassCount++;
                        if (self.verbosity > 1)
                            _WOLog(@"Class %@ does not comply with the WOTest protocol", className);
                    }
                }
                @catch (id exception)
                {
                    exceptionCount++;
                    // a number of classes are known to provoke exceptions:
                    if (self.verbosity > 1)
                        _WOLog(@"Cannot test protocol compliance for class %@ (caught exception)", className);
                    continue;
                }
            }
            free(classes);
        }

    }
    @catch (id e)
    {
        _WOLog(@"Uncaught exception...");
    }

    _WOLog(@"Runtime Summary:\n"
           @"Total classes:                                         %d\n"
           @"Classes which conform to the WOTest protocol:          %d\n"
           @"Classes which do not conform to the protocol:          %d\n"
           @"Classes excluded from scanning:                        %d\n"
           @"Classes that could not be scanned due to exceptions:   %d",
           classCount,
           conformingClassCount,
           nonconformingClassCount,
           excludedClassCount,
           exceptionCount);

    return [testableClasses sortedArrayUsingSelector:@selector(compare:)];
}

- (NSArray *)testableClassesFrom:(NSBundle *)aBundle
{
    NSMutableArray  *classNames = [NSMutableArray array];

    if (aBundle)    // only search if actually passed a non-nil bundle
    {
        // add only classes that match the passed bundle and conform to WOTest
        for (NSString *className in [self testableClasses])
        {
            Class       aClass          = NSClassFromString(className);
            NSBundle    *classBundle    = [NSBundle bundleForClass:aClass];
            if ([classBundle isEqualTo:aBundle])
                [classNames addObject:className];
        }
    }

    // return autoreleased, immutable NSArray
    return [NSArray arrayWithArray:classNames];
}

- (NSArray *)testableMethodsFrom:(Class)aClass
{
    // catch crashes caused by passing an "id" instead of a "Class"
    NSParameterAssert([NSObject WOTest_isRegisteredClass:aClass] || [NSObject WOTest_isMetaClass:aClass]);

    NSMutableArray *methodNames = [NSMutableArray array];
    @try
    {
        NSString *prefix = @"-";            // default prefix (instance methods)
        if (class_isMetaClass(aClass))
            prefix = @"+";                  // special prefix (class methods)
        else                                // this is not a metaclass
        {
            // get the metaclass; could also use object_getClass
            Class   metaClass       = object_getClass(aClass);
            NSArray *classMethods   = [self testableMethodsFrom:metaClass];
            [methodNames addObjectsFromArray:classMethods];
        }

        unsigned int count;
        Method *methods = class_copyMethodList(aClass, &count);
        if (methods)
        {
            for (unsigned int i = 0, max = count; i < max; i++)
            {
                SEL         aSelector   = method_getName(methods[i]);
                NSString    *name       = NSStringFromSelector(aSelector);
                if (name && [name hasPrefix:@"test"])
                    [methodNames addObject:[NSString stringWithFormat:@"%@%@", prefix, name]];
            }
            free(methods);
        }
    }
    @catch (id e)
    {
        NSString *error = [NSString stringWithFormat:@"exception caught trying to identify testable methods in class %@",
            NSStringFromClass(aClass)];
        [self writeError:error];
    }

    return [methodNames sortedArrayUsingSelector:@selector(compare:)];
}

- (void)printTestResultsSummary;
{
    [self checkStartDate];  // just in case no tests were run, make sure that startDate is non-nil
    double      successRate = 0.0;
    double      failureRate = 0.0;
    if (self.testsRun > 0)  // watch out for divide-by-zero if no tests run
    {
        successRate = ((double)(self.testsPassed + self.testsFailedExpected)    / (double)self.testsRun) * 100.0;
        failureRate = ((double)(self.testsFailed + self.testsPassedUnexpected)  / (double)self.testsRun) * 100.0;
    }
    _WOLog(@"Run summary:\n"
           @"Tests run:                         %d\n"
           @"Tests passed:                      %d + %d expected failures (%.2f%% success rate)\n"
           @"Tests failed:                      %d + %d unexpected passes (%.2f%% failure rate)\n"
           @"Uncaught exceptions:               %d\n"
           @"Low-level exceptions (crashers):   %d + %d expected\n"
           @"Total run time:                    %.2f seconds\n",
           self.testsRun,
           self.testsPassed,    self.testsFailedExpected,   successRate,
           self.testsFailed,    self.testsPassedUnexpected, failureRate,
           self.uncaughtExceptions,
           self.lowLevelExceptionsUnexpected,   self.lowLevelExceptionsExpected,
           -[self.startDate timeIntervalSinceNow]);

    if (self.testsRun == 0)
        _WOLog(@"warning: no tests were run\n");

    // TODO: make Growl notifications optional
    // TODO: include information about project being tested in Growl notification title
    // TODO: add options for showing coalesced growl notifications showing individual test failures (with path and line info)
    // TODO: make clicking on notification bring Xcode to the front, or open the file with the last failure in it etc
    NSString *status = [NSString stringWithFormat:@"%d tests passed, %d tests failed",
        self.testsPassed + self.testsFailedExpected, self.testsFailed + self.testsPassedUnexpected];

    if ([self testsWereSuccessful])
        [self growlNotifyTitle:@"WOTest run successful" message:status isWarning:NO sticky:NO];
    else
    {
        _WOLog(@"error: testing did not complete without errors\n");
        [self growlNotifyTitle:@"WOTest run failed" message:status isWarning:YES sticky:YES];

    }

    // reset start date
    self.startDate = nil;
}

- (BOOL)testsWereSuccessful
{
    return ((self.testsFailed + self.testsPassedUnexpected + self.uncaughtExceptions + self.lowLevelExceptionsUnexpected) == 0);
}

#pragma mark -
#pragma mark Low-level exception handling

- (void)installLowLevelExceptionHandler
{
    if (!lowLevelExceptionHandlerInstalled)
    {
        WOOldLowLevelExceptionHandler = InstallExceptionHandler(NewExceptionHandlerUPP(WOLowLevelExceptionHandler));
        lowLevelExceptionHandlerInstalled = YES;
    }
}

- (void)removeLowLevelExceptionHandler
{
    if (lowLevelExceptionHandlerInstalled)
    {
        DisposeExceptionHandlerUPP(InstallExceptionHandler(WOOldLowLevelExceptionHandler));
        lowLevelExceptionHandlerInstalled = NO;
    }
}

#pragma mark -
#pragma mark Growl support

- (void)growlNotifyTitle:(NSString *)title message:(NSString *)message isWarning:(BOOL)isWarning sticky:(BOOL)sticky
{
    NSParameterAssert(title != nil);
    NSParameterAssert(message != nil);

    // clean up enviroment a bit (hides possible warnings caused if these set for WOTestRunner)
    NSMutableDictionary *environment = [NSMutableDictionary dictionaryWithDictionary:[[NSProcessInfo processInfo] environment]];
    [environment removeObjectForKey:@"DYLD_INSERT_LIBRARIES"];
    [environment removeObjectForKey:@"WOTestBundleInjector"];

    NSTask *task = [[[NSTask alloc] init] autorelease];
    [task setLaunchPath:@"/usr/bin/env"];   // use env so as to pick up PATH, if set
    [task setEnvironment:environment];
    NSMutableArray *arguments = [NSMutableArray arrayWithObjects:@"growlnotify",
        @"--name",      @"com.wincent.WOTest",
        @"--appIcon",   @"Xcode",
        @"--priority",  (isWarning ? @"2" : @"0"),
        @"--message",   message,
        title,          nil];
    if (sticky) [arguments insertObject:@"--sticky" atIndex:0];
    [task setArguments:arguments];

    // if env can't find growl it will write a message like "env: growlnotify: No such file or directory" to the standard error
    // suppress it by redirecting the standard error to /dev/null
    [task setStandardError:[NSFileHandle fileHandleForWritingAtPath:@"/dev/null"]];

    @try
    {
        [task launch];
        [task waitUntilExit];

        // handle error conditions
        if (![task isRunning])
        {
            int status = [task terminationStatus];
            if (status == 127)  // env returns this when "[t]he utility specified by utility could not be found"
                _WOLog(@"note: growlnotify not launched (not found in the current PATH)");
            else if (status != EXIT_SUCCESS)
                // a failure to run growlnotify is relatively harmless, so use warning rather than error
                _WOLog(@"warning: env terminated with exit status %d while trying to run growlnotify", status);
        }
    }
    @catch (NSException *e)
    {
        // highly unlikely that we'd ever get here, but report it anyway
        _WOLog(@"warning: exception caught while trying to execute growlnotify using env (%@: %@)", [e name], [e reason]);
    }
}

#pragma mark -
#pragma mark Logging methods

- (NSString *)trimmedPath:(char *)path
{
    NSParameterAssert(path != NULL);
    NSString *pathString = [NSString stringWithUTF8String:path];

    unsigned trim = self.trimInitialPathComponents;
    if (trim == 0) return pathString;
    if (![pathString isAbsolutePath]) return pathString;    // only trim absolute paths
    NSArray *components = [pathString pathComponents];      // note: Cocoa returns "/" here as an additional first component
    NSAssert(components != nil, @"components != nil");
    unsigned count = [components count];
    if (count < trim + 2) return pathString;                // only trim if there will be at least one component left over
    return [NSString pathWithComponents:[components subarrayWithRange:NSMakeRange(trim + 1, count - trim - 1)]];
}

- (void)writePassed:(BOOL)passed inFile:(char *)path atLine:(int)line message:(NSString *)message, ...
{
    self.testsRun++;
    va_list args;
    va_start(args, message);
    NSString *string = [NSString WOTest_stringWithFormat:message arguments:args];
    va_end(args);
    if (self.expectFailures)    // invert sense of tests (ie. failure is good)
    {
        if (passed)             // passed: bad
        {
            [self writeErrorInFile:path atLine:line message:[NSString stringWithFormat:@"Passed (unexpected pass): %@", string]];
            self.testsPassedUnexpected++;
        }
        else                    // failed: good
        {
            [self writeStatusInFile:path atLine:line message:[NSString stringWithFormat:@"Failed (expected failure): %@", string]];
            self.testsFailedExpected++;
        }
    }
    else                        // normal handling (ie. passing is good, failing is bad)
    {
        if (passed)             // passed: good
        {
            [self writeStatusInFile:path atLine:line message:[NSString stringWithFormat:@"Passed: %@", string]];
            self.testsPassed++;
        }
        else                    // failed: bad
        {
            [self writeErrorInFile:path atLine:line message:[NSString stringWithFormat:@"Failed: %@", string]];
            self.testsFailed++;
        }
    }
}

- (void)cacheFile:(char *)path line:(int)line
{
    self.lastReportedFile   = [self trimmedPath:path];
    self.lastReportedLine   = line;
}

- (void)writeLastKnownLocation
{
    NSString *path = self.lastReportedFile;
    if (path)
        _WOLog(@"%@:%d: last known location was %@:%d", path, self.lastReportedLine, path, self.lastReportedLine);
}

- (void)writeErrorInFile:(char *)path atLine:(int)line message:(NSString *)message, ...
{
    va_list args;
    va_start(args, message);
    NSString *error = [NSString WOTest_stringWithFormat:message arguments:args];
    _WOLog(@"%@:%d: error: %@", [self trimmedPath:path], line, error);
    [self cacheFile:path line:line];
    va_end(args);
}

- (void)writeWarningInFile:(char *)path atLine:(int)line message:(NSString *)message, ...
{
    va_list args;
    va_start(args, message);
    NSString *warning = [NSString WOTest_stringWithFormat:message arguments:args];
    _WOLog(@"%@:%d: warning: %@", [self trimmedPath:path], line, warning);
    [self cacheFile:path line:line];
    va_end(args);
}

- (void)writeUncaughtException:(NSString *)info inFile:(char *)path atLine:(int)line
{
    _WOLog(@"%@:%d: error: uncaught exception during test execution: %@", [self trimmedPath:path], line, info);
    self.uncaughtExceptions++;
}

- (void)writeStatusInFile:(char *)path atLine:(int)line message:(NSString *)message, ...
{
    va_list args;
    va_start(args, message);
    NSString *status = [NSString WOTest_stringWithFormat:message arguments:args];
    _WOLog(@"%@:%d %@", [self trimmedPath:path], line, status); // omit colin after line number or Xcode will show this as an error
    [self cacheFile:path line:line];
    va_end(args);
}

- (void)writeStatus:(NSString *)message, ...
{
    va_list args;
    va_start(args, message);
    NSString *status = [NSString WOTest_stringWithFormat:message arguments:args];
    _WOLog(@"%@", status);
    va_end(args);
}

- (void)writeWarning:(NSString *)message, ...
{
    va_list args;
    va_start(args, message);
    NSString *warning = [NSString WOTest_stringWithFormat:message arguments:args];
    _WOLog(@"warning: %@", warning); // older versions of Xcode required initial colons "::" to show this as a warning
    va_end(args);
}

- (void)writeError:(NSString *)message, ...
{
    va_list args;
    va_start(args, message);
    NSString *error = [NSString WOTest_stringWithFormat:message arguments:args];
    _WOLog(@"error: %@", error); // older versions of Xcode required initial colons "::" to show this as an error
    va_end(args);
}

#pragma mark -
#pragma mark Empty (do-nothing) test methods

- (void)passTestInFile:(char *)path atLine:(int)line
{
    [self writePassed:YES inFile:path atLine:line message:@"(always passes)"];
}

- (void)failTestInFile:(char *)path atLine:(int)line
{
    [self writePassed:NO inFile:path atLine:line message:@"(always fails)"];
}

#pragma mark -
#pragma mark Boolean test methods

- (void)testTrue:(BOOL)expr inFile:(char *)path atLine:(int)line
{
    [self writePassed:expr inFile:path atLine:line message:@"expected YES, got %@", (expr ? @"YES" : @"NO")];
}

- (void)testFalse:(BOOL)expr inFile:(char *)path atLine:(int)line
{
    [self writePassed:!expr inFile:path atLine:line message:@"expected NO, got %@", (expr ? @"YES" : @"NO")];
}

#pragma mark -
#pragma mark NSValue-based tests

- (void)testValue:(NSValue *)actual isEqualTo:(NSValue *)expected inFile:(char *)path atLine:(int)line
{
    NSParameterAssert(actual);
    NSParameterAssert(expected);
    BOOL equal = NO;

    // NSValue category will throw an exception for invalid input(s)
    @try {
        equal = [actual WOTest_testIsEqualToValue:expected];
    }
    @catch (id e) {
        [self writeErrorInFile:path atLine:line message:@"uncaught exception (%@)", [NSException WOTest_descriptionForException:e]];
        self.uncaughtExceptions++;
    }
    BOOL expectedTruncated, actualTruncated;
    [self writePassed:equal inFile:path atLine:line message:@"expected %@, got %@", WO_DESC(expected), WO_DESC(actual)];
    if (expectedTruncated)  _WOLog(@"expected result (not truncated): %@", WO_LONG_DESC(expected));
    if (actualTruncated)    _WOLog(@"actual result (not truncated): %@", WO_LONG_DESC(actual));
}

- (void)testValue:(NSValue *)actual isNotEqualTo:(NSValue *)expected inFile:(char *)path atLine:(int)line
{
    NSParameterAssert(actual);
    NSParameterAssert(expected);
    BOOL equal = NO;

    // NSValue category will throw an exception for invalid input(s)
    @try {
        equal = [actual WOTest_testIsEqualToValue:expected];
    }
    @catch (id e) {
        [self writeErrorInFile:path atLine:line message:@"uncaught exception (%@)", [NSException WOTest_descriptionForException:e]];
        self.uncaughtExceptions++;
    }
    BOOL expectedTruncated, actualTruncated;
    [self writePassed:(!equal) inFile:path atLine:line message:@"expected (not) %@, got %@", WO_DESC(expected), WO_DESC(actual)];
    if (expectedTruncated)  _WOLog(@"expected result (not truncated): %@", WO_LONG_DESC(expected));
    if (actualTruncated)    _WOLog(@"actual result (not truncated): %@", WO_LONG_DESC(actual));
}

- (void)testValue:(NSValue *)actual greaterThan:(NSValue *)expected inFile:(char *)path atLine:(int)line
{
    NSParameterAssert(actual);
    NSParameterAssert(expected);
    BOOL greaterThan = NO;

    // NSValue category will throw an exception for invalid input(s)
    @try {
        greaterThan = [actual WOTest_testIsGreaterThanValue:expected];
    }
    @catch (id e) {
        [self writeErrorInFile:path atLine:line message:@"uncaught exception (%@)", [NSException WOTest_descriptionForException:e]];
        self.uncaughtExceptions++;
    }
    BOOL expectedTruncated, actualTruncated;
    [self writePassed:greaterThan inFile:path atLine:line message:@"expected > %@, got %@", WO_DESC(expected), WO_DESC(actual)];
    if (expectedTruncated)  _WOLog(@"expected result (not truncated): %@", WO_LONG_DESC(expected));
    if (actualTruncated)    _WOLog(@"actual result (not truncated): %@", WO_LONG_DESC(actual));
}

- (void)testValue:(NSValue *)actual notGreaterThan:(NSValue *)expected inFile:(char *)path atLine:(int)line
{
    NSParameterAssert(actual);
    NSParameterAssert(expected);
    BOOL notGreaterThan = NO;

    // NSValue category will throw an exception for invalid input(s)
    @try {
        notGreaterThan = [actual WOTest_testIsNotGreaterThanValue:expected];
    }
    @catch (id e) {
        [self writeErrorInFile:path atLine:line message:@"uncaught exception (%@)", [NSException WOTest_descriptionForException:e]];
        self.uncaughtExceptions++;
    }
    BOOL expectedTruncated, actualTruncated;
    [self writePassed:notGreaterThan inFile:path atLine:line message:@"expected <= %@, got %@", WO_DESC(expected), WO_DESC(actual)];
    if (expectedTruncated)  _WOLog(@"expected result (not truncated): %@", WO_LONG_DESC(expected));
    if (actualTruncated)    _WOLog(@"actual result (not truncated): %@", WO_LONG_DESC(actual));
}

- (void)testValue:(NSValue *)actual lessThan:(NSValue *)expected inFile:(char *)path atLine:(int)line
{
    NSParameterAssert(actual);
    NSParameterAssert(expected);
    BOOL lessThan = NO;

    // NSValue category will throw an exception for invalid input(s)
    @try {
        lessThan = [actual WOTest_testIsLessThanValue:expected];
    }
    @catch (id e) {
        [self writeErrorInFile:path atLine:line message:@"uncaught exception (%@)", [NSException WOTest_descriptionForException:e]];
        self.uncaughtExceptions++;
    }
    BOOL expectedTruncated, actualTruncated;
    [self writePassed:lessThan inFile:path atLine:line message:@"expected < %@, got %@", WO_DESC(expected), WO_DESC(actual)];
    if (expectedTruncated)  _WOLog(@"expected result (not truncated): %@", WO_LONG_DESC(expected));
    if (actualTruncated)    _WOLog(@"actual result (not truncated): %@", WO_LONG_DESC(actual));
}

- (void)testValue:(NSValue *)actual notLessThan:(NSValue *)expected inFile:(char *)path atLine:(int)line
{
    NSParameterAssert(actual);
    NSParameterAssert(expected);
    BOOL notLessThan = NO;

    // NSValue category will throw an exception for invalid input(s)
    @try {
        notLessThan = [actual WOTest_testIsNotLessThanValue:expected];
    }
    @catch (id e) {
        [self writeErrorInFile:path atLine:line message:@"uncaught exception (%@)", [NSException WOTest_descriptionForException:e]];
        self.uncaughtExceptions++;
    }
    BOOL expectedTruncated, actualTruncated;
    [self writePassed:notLessThan inFile:path atLine:line message:@"expected >= %@, got %@", WO_DESC(expected), WO_DESC(actual)];
    if (expectedTruncated)  _WOLog(@"expected result (not truncated): %@", WO_LONG_DESC(expected));
    if (actualTruncated)    _WOLog(@"actual result (not truncated): %@", WO_LONG_DESC(actual));
}

#pragma mark -
#pragma mark Pointer to void test methods

- (void)testNil:(void *)pointer inFile:(char *)path atLine:(int)line
{
    BOOL result = (pointer ? NO : YES);
    [self writePassed:result inFile:path atLine:line message:@"expected nil, got %@",
        (result ? @"nil" : [NSString stringWithFormat:@"%x", pointer])];
}

- (void)testNotNil:(void *)pointer inFile:(char *)path atLine:(int)line
{
    BOOL result = (pointer ? YES : NO);
    [self writePassed:result inFile:path atLine:line message:@"expected (not) nil, got %@",
        (result ? [NSString stringWithFormat:@"%x", pointer] : @"nil")];
}

- (void)testPointer:(void *)actual isEqualTo:(void *)expected inFile:(char *)path atLine:(int)line
{
    BOOL result = (actual == expected);
    [self writePassed:result inFile:path atLine:line message:@"expected %x, got %x", expected, actual];
}

- (void)testPointer:(void *)actual isNotEqualTo:(void *)expected inFile:(char *)path atLine:(int)line
{
    BOOL result = (actual != expected);
    [self writePassed:result inFile:path atLine:line message:@"expected (not) %x, got %x", expected, actual];
}

#pragma mark -
#pragma mark int test methods

- (void)testIsInt:(char *)type inFile:(char *)path atLine:(int)line
{
    BOOL result = (strcmp(type, "i") == 0);
    [self writePassed:result inFile:path atLine:line message:[NSString stringWithFormat: @"expected type \"i\", got \"%s\"", type]];
}

- (void)testIsNotInt:(char *)type inFile:(char *)path atLine:(int)line
{
    BOOL result = (strcmp(type, "i") != 0);
    [self writePassed:result
               inFile:path
               atLine:line
              message:[NSString stringWithFormat:@"expected type (not) \"i\", got \"%s\"", type]];
}

- (void)testIntPositive:(int)aInt inFile:(char *)path atLine:(int)line
{
    [self testInt:aInt greaterThan:(int)0 inFile:path atLine:line];
}

- (void)testIntNegative:(int)aInt inFile:(char *)path atLine:(int)line
{
    [self testInt:aInt lessThan:(int)0 inFile:path atLine:line];
}

- (void)testIntZero:(int)aInt inFile:(char *)path atLine:(int)line
{
    [self testInt:aInt isEqualTo:(int)0 inFile:path atLine:line];
}

- (void)testIntNotZero:(int)aInt inFile:(char *)path atLine:(int)line
{
    [self testInt:aInt isNotEqualTo:(int)0 inFile:path atLine:line];
}

- (void)testInt:(int)actual isEqualTo:(int)expected inFile:(char *)path atLine:(int)line
{
    BOOL result = (actual == expected);
    [self writePassed:result inFile:path atLine:line message:[NSString stringWithFormat:@"expected %d, got %d", expected, actual]];
}

- (void)testInt:(int)actual isNotEqualTo:(int)expected inFile:(char *)path atLine:(int)line
{
    BOOL result = (actual != expected);
    [self writePassed:result
               inFile:path
               atLine:line
              message:[NSString stringWithFormat:@"expected (not) %d, got %d", expected, actual]];
}

- (void)testInt:(int)actual greaterThan:(int)expected inFile:(char *)path atLine:(int)line
{
    BOOL result = (actual > expected);
    [self writePassed:result
               inFile:path
               atLine:line
              message:[NSString stringWithFormat:@"expected > %d, got %d", expected, actual]];
}

- (void)testInt:(int)actual notGreaterThan:(int)expected inFile:(char *)path atLine:(int)line
{
    BOOL result = (actual <= expected);
    [self writePassed:result
               inFile:path
               atLine:line
              message:[NSString stringWithFormat:@"expected <= %d, got %d", expected, actual]];
}

- (void)testInt:(int)actual lessThan:(int)expected inFile:(char *)path atLine:(int)line
{
    BOOL result = (actual < expected);
    [self writePassed:result
               inFile:path
               atLine:line
              message:[NSString stringWithFormat:@"expected < %d, got %d", expected, actual]];
}

- (void)testInt:(int)actual notLessThan:(int)expected inFile:(char *)path atLine:(int)line
{
    BOOL result = (actual >= expected);
    [self writePassed:result
               inFile:path
               atLine:line
              message:[NSString stringWithFormat:@"expected >= %d, got %d", expected, actual]];
}

#pragma mark -
#pragma mark unsigned test methods

- (void)testIsUnsigned:(char *)type inFile:(char *)path atLine:(int)line
{
    BOOL result = (strcmp(type, "I") == 0);
    [self writePassed:result inFile:path atLine:line message:[NSString stringWithFormat: @"expected type \"I\", got \"%s\"", type]];
}

- (void)testIsNotUnsigned:(char *)type inFile:(char *)path atLine:(int)line
{
    BOOL result = (strcmp(type, "I") != 0);
    [self writePassed:result
               inFile:path
               atLine:line
              message:[NSString stringWithFormat:@"expected type (not) \"I\", got \"%s\"", type]];
}

- (void)testUnsignedZero:(unsigned)aUnsigned inFile:(char *)path atLine:(int)line
{
    return [self testUnsigned:aUnsigned isEqualTo:(unsigned)0 inFile:path atLine:line];
}

- (void)testUnsignedNotZero:(unsigned)aUnsigned inFile:(char *)path atLine:(int)line
{
    return [self testUnsigned:aUnsigned isNotEqualTo:(unsigned)0 inFile:path atLine:line];
}

- (void)testUnsigned:(unsigned)actual isEqualTo:(unsigned)expected inFile:(char *)path atLine:(int)line
{
    BOOL result = (actual == expected);
    [self writePassed:result
               inFile:path
               atLine:line
              message:[NSString stringWithFormat:@"expected %u, got %u", expected, actual]];
}

- (void)testUnsigned:(unsigned)actual isNotEqualTo:(unsigned)expected inFile:(char *)path atLine:(int)line
{
    BOOL result = (actual != expected);
    [self writePassed:result
               inFile:path
               atLine:line
              message:[NSString stringWithFormat:@"expected (not) %u, got %u", expected, actual]];
}

- (void)testUnsigned:(unsigned)actual greaterThan:(unsigned)expected inFile:(char *)path atLine:(int)line
{
    BOOL result = (actual > expected);
    [self writePassed:result
               inFile:path
               atLine:line
              message:[NSString stringWithFormat:@"expected > %u, got %u", expected, actual]];
}

- (void)testUnsigned:(unsigned)actual notGreaterThan:(unsigned)expected inFile:(char *)path atLine:(int)line
{
    BOOL result = (actual <= expected);
    [self writePassed:result
               inFile:path
               atLine:line
              message:[NSString stringWithFormat:@"expected <= %u, got %u", expected, actual]];
}

- (void)testUnsigned:(unsigned)actual lessThan:(unsigned)expected inFile:(char *)path atLine:(int)line
{
    BOOL result = (actual < expected);
    [self writePassed:result
               inFile:path
               atLine:line
              message:[NSString stringWithFormat:@"expected < %u, got %u", expected, actual]];
}

- (void)testUnsigned:(unsigned)actual notLessThan:(unsigned)expected inFile:(char *)path atLine:(int)line
{
    BOOL result = (actual >= expected);
    [self writePassed:result
               inFile:path
               atLine:line
              message:[NSString stringWithFormat:@"expected >= %u, got %u", expected, actual]];
}

#pragma mark -
#pragma mark float test methods without error margins

- (void)testIsFloat:(char *)type inFile:(char *)path atLine:(int)line
{
    BOOL result = (strcmp(type, "f") == 0);
    [self writePassed:result inFile:path atLine:line message:[NSString stringWithFormat: @"expected type \"f\", got \"%s\"", type]];
}

- (void)testIsNotFloat:(char *)type inFile:(char *)path atLine:(int)line
{
    BOOL result = (strcmp(type, "f") != 0);
    [self writePassed:result
               inFile:path
               atLine:line
              message:[NSString stringWithFormat:@"expected type (not) \"f\", got \"%s\"", type]];
}

- (void)testFloatPositive:(float)aFloat inFile:(char *)path atLine:(int)line
{
    return [self testFloat:aFloat greaterThan:(float)0.0 withinError:(float)0.0 inFile:path atLine:line];
}

- (void)testFloatNegative:(float)aFloat inFile:(char *)path atLine:(int)line
{
    return [self testFloat:aFloat lessThan:(float)0.0 withinError:(float)0.0 inFile:path atLine:line];
}

- (void)testFloatZero:(float)aFloat inFile:(char *)path atLine:(int)line
{
    return [self testFloat:aFloat isEqualTo:(float)0.0 withinError:(float)0.0 inFile:path atLine:line];
}

- (void)testFloatNotZero:(float)aFloat inFile:(char *)path atLine:(int)line
{
    return [self testFloat:aFloat isNotEqualTo:(float)0.0 withinError:(float)0.0 inFile:path atLine:line];
}

- (void)testFloat:(float)actual isEqualTo:(float)expected inFile:(char *)path atLine:(int)line
{
    return [self testFloat:actual isEqualTo:expected withinError:(float)0.0 inFile:path atLine:line];
}

- (void)testFloat:(float)actual isNotEqualTo:(float)expected inFile:(char *)path atLine:(int)line
{
    return [self testFloat:actual isNotEqualTo:expected withinError:(float)0.0 inFile:path atLine:line];
}

- (void)testFloat:(float)actual greaterThan:(float)expected inFile:(char *)path atLine:(int)line
{
    return [self testFloat:actual greaterThan:expected withinError:(float)0.0 inFile:path atLine:line];
}

- (void)testFloat:(float)actual notGreaterThan:(float)expected inFile:(char *)path atLine:(int)line
{
    return [self testFloat:actual notGreaterThan:expected withinError:(float)0.0 inFile:path atLine:line];
}

- (void)testFloat:(float)actual lessThan:(float)expected inFile:(char *)path atLine:(int)line
{
    return [self testFloat:actual lessThan:expected withinError:(float)0.0 inFile:path atLine:line];
}

- (void)testFloat:(float)actual notLessThan:(float)expected inFile:(char *)path atLine:(int)line
{
    return [self testFloat:actual notLessThan:expected withinError:(float)0.0 inFile:path atLine:line];
}

#pragma mark -
#pragma mark float test methods with error margins

- (void)testFloatPositive:(float)aFloat withinError:(float)error inFile:(char *)path atLine:(int)line
{
    return [self testFloat:aFloat greaterThan:(float)0.0 withinError:error inFile:path atLine:line];
}

- (void)testFloatNegative:(float)aFloat withinError:(float)error inFile:(char *)path atLine:(int)line
{
    return [self testFloat:aFloat lessThan:(float)0.0 withinError:error inFile:path atLine:line];
}

- (void)testFloatZero:(float)aFloat withinError:(float)error inFile:(char *)path atLine:(int)line
{
    return [self testFloat:aFloat isEqualTo:(float)0.0 withinError:error inFile:path atLine:line];
}

- (void)testFloatNotZero:(float)aFloat withinError:(float)error inFile:(char *)path atLine:(int)line
{
    return [self testFloat:aFloat isNotEqualTo:(float)0.0 withinError:error inFile:path atLine:line];
}

- (void)testFloat:(float)actual isEqualTo:(float)expected withinError:(float)error inFile:(char *)path atLine:(int)line
{
    BOOL result = (fabsf(actual - expected) <= error);
    [self writePassed:result
               inFile:path
               atLine:line
              message:
        [NSString stringWithFormat:@"expected %f (%C%f), got %f", expected, WO_UNICODE_PLUS_MINUS_SIGN, error, actual]];
}

- (void)testFloat:(float)actual isNotEqualTo:(float)expected withinError:(float)error inFile:(char *)path atLine:(int)line
{
    BOOL result = (fabsf(actual - expected) > -error);
    [self writePassed:result
               inFile:path
               atLine:line
              message:
        [NSString stringWithFormat:@"expected (not) %f (%C%f), got %f", expected, WO_UNICODE_PLUS_MINUS_SIGN, error, actual]];
}

- (void)testFloat:(float)actual greaterThan:(float)expected withinError:(float)error inFile:(char *)path atLine:(int)line
{
    BOOL result = ((actual - expected) > -error);
    [self writePassed:result
               inFile:path
               atLine:line
              message:
        [NSString stringWithFormat:@"expected > %f (%C%f), got %f", expected, WO_UNICODE_PLUS_MINUS_SIGN, error, actual]];
}

- (void)testFloat:(float)actual notGreaterThan:(float)expected withinError:(float)error inFile:(char *)path atLine:(int)line
{
    BOOL result = ((actual - expected) <= error);
    [self writePassed:result
               inFile:path
               atLine:line
              message:
        [NSString stringWithFormat:@"expected <= %f (%C%f), got %f", expected, WO_UNICODE_PLUS_MINUS_SIGN, error, actual]];
}

- (void)testFloat:(float)actual lessThan:(float)expected withinError:(float)error inFile:(char *)path atLine:(int)line
{
    BOOL result = ((actual - expected) < -error);
    [self writePassed:result
               inFile:path
               atLine:line
              message:
        [NSString stringWithFormat:@"expected < %f (%C%f), got %f", expected, WO_UNICODE_PLUS_MINUS_SIGN, error, actual]];
}

- (void)testFloat:(float)actual notLessThan:(float)expected withinError:(float)error inFile:(char *)path atLine:(int)line
{
    BOOL result = ((actual - expected) >= error);
    [self writePassed:result
               inFile:path
               atLine:line
              message:
        [NSString stringWithFormat:@"expected >= %f (%C%f), got %f", expected, WO_UNICODE_PLUS_MINUS_SIGN, error, actual]];
}

#pragma mark -
#pragma mark double test methods without error margins

- (void)testIsDouble:(char *)type inFile:(char *)path atLine:(int)line
{
    BOOL result = (strcmp(type, "d") == 0);
    [self writePassed:result inFile:path atLine:line message:[NSString stringWithFormat: @"expected type \"d\", got \"%s\"", type]];
}

- (void)testIsNotDouble:(char *)type inFile:(char *)path atLine:(int)line
{
    BOOL result = (strcmp(type, "d") != 0);
    [self writePassed:result
               inFile:path
               atLine:line
              message:[NSString stringWithFormat:@"expected type (not) \"d\", got \"%s\"", type]];
}

- (void)testDoublePositive:(double)aDouble inFile:(char *)path atLine:(int)line
{
    return [self testDouble:aDouble greaterThan:(double)0.0 withinError:(double)0.0 inFile:path atLine:line];
}

- (void)testDoubleNegative:(double)aDouble inFile:(char *)path atLine:(int)line
{
    return [self testDouble:aDouble lessThan:(double)0.0 withinError:(double)0.0 inFile:path atLine:line];
}

- (void)testDoubleZero:(double)aDouble inFile:(char *)path atLine:(int)line
{
    return [self testDouble:aDouble isEqualTo:(double)0.0 withinError:(double)0.0 inFile:path atLine:line];
}

- (void)testDoubleNotZero:(double)aDouble inFile:(char *)path atLine:(int)line
{
    return [self testDouble:aDouble isNotEqualTo:(double)0.0 withinError:(double)0.0 inFile:path atLine:line];
}

- (void)testDouble:(double)actual isEqualTo:(double)expected inFile:(char *)path atLine:(int)line
{
    return [self testDouble:actual isEqualTo:expected withinError:(double)0.0 inFile:path atLine:line];
}

- (void)testDouble:(double)actual isNotEqualTo:(double)expected inFile:(char *)path atLine:(int)line
{
    return [self testDouble:actual isNotEqualTo:expected withinError:(double)0.0 inFile:path atLine:line];
}

- (void)testDouble:(double)actual greaterThan:(double)expected inFile:(char *)path atLine:(int)line
{
    return [self testDouble:actual greaterThan:expected withinError:(double)0.0 inFile:path atLine:line];
}

- (void)testDouble:(double)actual notGreaterThan:(double)expected inFile:(char *)path atLine:(int)line
{
    return [self testDouble:actual notGreaterThan:expected withinError:(double)0.0 inFile:path atLine:line];
}

- (void)testDouble:(double)actual lessThan:(double)expected inFile:(char *)path atLine:(int)line
{
    return [self testDouble:actual lessThan:expected withinError:(double)0.0 inFile:path atLine:line];
}

- (void)testDouble:(double)actual notLessThan:(double)expected inFile:(char *)path atLine:(int)line
{
    return [self testDouble:actual notLessThan:expected withinError:(double)0.0 inFile:path atLine:line];
}

#pragma mark -
#pragma mark double test methods with error margins

- (void)testDoublePositive:(double)aDouble withinError:(double)error inFile:(char *)path atLine:(int)line
{
    return [self testDouble:aDouble greaterThan:(double)0.0 withinError:error inFile:path atLine:line];
}

- (void)testDoubleNegative:(double)aDouble withinError:(double)error inFile:(char *)path atLine:(int)line
{
    return [self testDouble:aDouble lessThan:(double)0.0 withinError:error inFile:path atLine:line];
}

- (void)testDoubleZero:(double)aDouble withinError:(double)error inFile:(char *)path atLine:(int)line
{
    return [self testDouble:aDouble isEqualTo:(double)0.0 withinError:error inFile:path atLine:line];
}

- (void)testDoubleNotZero:(double)aDouble withinError:(double)error inFile:(char *)path atLine:(int)line
{
    return [self testDouble:aDouble isNotEqualTo:(double)0.0 withinError:error inFile:path atLine:line];
}

- (void)testDouble:(double)actual isEqualTo:(double)expected withinError:(double)error inFile:(char *)path atLine:(int)line
{
    BOOL result = (fabs(actual - expected) <= error);
    [self writePassed:result
               inFile:path
               atLine:line
              message:
        [NSString stringWithFormat:@"expected %f (%C%f), got %f", expected, WO_UNICODE_PLUS_MINUS_SIGN, error, actual]];
}

- (void)testDouble:(double)actual isNotEqualTo:(double)expected withinError:(double)error inFile:(char *)path atLine:(int)line
{
    BOOL result = (fabs(actual - expected) > -error);
    [self writePassed:result
               inFile:path
               atLine:line
              message:
        [NSString stringWithFormat:@"expected (not) %f (%C%f), got %f", expected, WO_UNICODE_PLUS_MINUS_SIGN, error, actual]];
}

- (void)testDouble:(double)actual greaterThan:(double)expected withinError:(double)error inFile:(char *)path atLine:(int)line
{
    BOOL result = ((actual - expected) > -error);
    [self writePassed:result
               inFile:path
               atLine:line
              message:
        [NSString stringWithFormat:@"expected > %f (%C%f), got %f", expected, WO_UNICODE_PLUS_MINUS_SIGN, error, actual]];
}

- (void)testDouble:(double)actual notGreaterThan:(double)expected withinError:(double)error inFile:(char *)path atLine:(int)line
{
    BOOL result = ((actual - expected) <= error);
    [self writePassed:result
               inFile:path
               atLine:line
              message:
        [NSString stringWithFormat:@"expected <= %f (%C%f), got %f", expected, WO_UNICODE_PLUS_MINUS_SIGN, error, actual]];
}

- (void)testDouble:(double)actual lessThan:(double)expected withinError:(double)error inFile:(char *)path atLine:(int)line
{
    BOOL result = ((actual - expected) < -error);
    [self writePassed:result
               inFile:path
               atLine:line
              message:
        [NSString stringWithFormat:@"expected < %f (%C%f), got %f", expected, WO_UNICODE_PLUS_MINUS_SIGN, error, actual]];
}

- (void)testDouble:(double)actual notLessThan:(double)expected withinError:(float)error inFile:(char *)path atLine:(int)line
{
    BOOL result = ((actual - expected) >= error);
    [self writePassed:result
               inFile:path
               atLine:line
              message:
        [NSString stringWithFormat:@"expected >= %f (%C%f), got %f", expected, WO_UNICODE_PLUS_MINUS_SIGN, error, actual]];
}

#pragma mark -
#pragma mark object test methods

- (void)testObject:(id)actual isEqualTo:(id)expected inFile:(char *)path atLine:(int)line
{
    BOOL equal = NO;
    if (!actual && !expected) equal = YES; // equal (both nil)
    else if (actual) equal = [actual isEqual:expected];
    BOOL expectedTruncated, actualTruncated;
    [self writePassed:equal inFile:path atLine:line message:@"expected \"%@\", got \"%@\"", WO_DESC(expected), WO_DESC(actual)];
    if (expectedTruncated)  _WOLog(@"expected result (not truncated): %@", WO_LONG_DESC(expected));
    if (actualTruncated)    _WOLog(@"actual result (not truncated): %@", WO_LONG_DESC(actual));
}

- (void)testObject:(id)actual isNotEqualTo:(id)expected inFile:(char *)path atLine:(int)line
{
    BOOL equal = NO;
    if (!actual && !expected) equal = YES; // equal (both nil)
    else if (actual) equal = [actual isEqual:expected];
    BOOL expectedTruncated, actualTruncated;
    [self writePassed:(!equal)
               inFile:path
               atLine:line
              message:@"expected (not) \"%@\", got \"%@\"", WO_DESC(expected), WO_DESC(actual)];
    if (expectedTruncated)  _WOLog(@"expected result (not truncated): %@", WO_LONG_DESC(expected));
    if (actualTruncated)    _WOLog(@"actual result (not truncated): %@", WO_LONG_DESC(actual));
}

#pragma mark -
#pragma mark NSString test methods

- (void)testString:(NSString *)actual isEqualTo:(NSString *)expected inFile:(char *)path atLine:(int)line
{
    if (actual && ![actual isKindOfClass:[NSString class]])
        [NSException WOTest_raise:WO_TEST_CLASS_MISMATCH_EXCEPTION
                           reason:WO_EXPECTED_STRING_EXCEPTION_REASON(actual)
                           inFile:path
                           atLine:line];
    if (expected && ![expected isKindOfClass:[NSString class]])
        [NSException WOTest_raise:WO_TEST_CLASS_MISMATCH_EXCEPTION
                           reason:WO_EXPECTED_STRING_EXCEPTION_REASON(expected)
                           inFile:path
                           atLine:line];
    BOOL equal = NO;
    if (!actual && !expected) equal = YES; // equal (both nil)
    else if (actual) equal = [actual isEqualToString:expected];
    BOOL expectedTruncated, actualTruncated;
    [self writePassed:equal inFile:path atLine:line message:@"expected \"%@\", got \"%@\"", WO_DESC(expected), WO_DESC(actual)];
    if (expectedTruncated)  _WOLog(@"expected result (not truncated): %@", WO_LONG_DESC(expected));
    if (actualTruncated)    _WOLog(@"actual result (not truncated): %@", WO_LONG_DESC(actual));
}

- (void)testString:(NSString *)actual isNotEqualTo:(NSString *)expected inFile:(char *)path atLine:(int)line
{
    if (actual && ![actual isKindOfClass:[NSString class]])
        [NSException WOTest_raise:WO_TEST_CLASS_MISMATCH_EXCEPTION
                           reason:WO_EXPECTED_STRING_EXCEPTION_REASON(actual)
                           inFile:path
                           atLine:line];
    if (expected && ![expected isKindOfClass:[NSString class]])
        [NSException WOTest_raise:WO_TEST_CLASS_MISMATCH_EXCEPTION
                           reason:WO_EXPECTED_STRING_EXCEPTION_REASON(expected)
                           inFile:path
                           atLine:line];
    BOOL equal = NO;
    if (!actual && !expected) equal = YES; // equal (both nil)
    else if (actual) equal = [actual isEqualToString:expected];
    BOOL expectedTruncated, actualTruncated;
    [self writePassed:equal
               inFile:path
               atLine:line
              message:@"expected (not) \"%@\", got \"%@\"", WO_DESC(expected), WO_DESC(actual)];
    if (expectedTruncated)  _WOLog(@"expected result (not truncated): %@", WO_LONG_DESC(expected));
    if (actualTruncated)    _WOLog(@"actual result (not truncated): %@", WO_LONG_DESC(actual));
}

- (void)testString:(NSString *)actual hasPrefix:(NSString *)expected inFile:(char *)path atLine:(int)line
{
    if (!expected)
        [NSException WOTest_raise:WO_TEST_NIL_PARAMETER_EXCEPTION
                           reason:WO_NIL_PARAMETER_EXCEPTION_REASON
                           inFile:path
                           atLine:line];
    if (actual && ![actual isKindOfClass:[NSString class]])
        [NSException WOTest_raise:WO_TEST_CLASS_MISMATCH_EXCEPTION
                           reason:WO_EXPECTED_STRING_EXCEPTION_REASON(actual)
                           inFile:path
                           atLine:line];
    if (![expected isKindOfClass:[NSString class]])
        [NSException WOTest_raise:WO_TEST_CLASS_MISMATCH_EXCEPTION
                           reason:WO_EXPECTED_STRING_EXCEPTION_REASON(expected)
                           inFile:path
                           atLine:line];
    BOOL result = actual ? NO : [actual hasPrefix:expected];
    BOOL expectedTruncated, actualTruncated;
    [self writePassed:result
               inFile:path
               atLine:line
              message:@"expected prefix \"%@\", got \"%@\"", WO_DESC(expected), WO_DESC(actual)];
    if (expectedTruncated)  _WOLog(@"expected result (not truncated): %@", WO_LONG_DESC(expected));
    if (actualTruncated)    _WOLog(@"actual result (not truncated): %@", WO_LONG_DESC(actual));
}

- (void)testString:(NSString *)actual doesNotHavePrefix:(NSString *)expected inFile:(char *)path atLine:(int)line
{
    if (!expected)
        [NSException WOTest_raise:WO_TEST_NIL_PARAMETER_EXCEPTION
                           reason:WO_NIL_PARAMETER_EXCEPTION_REASON
                           inFile:path
                           atLine:line];
    if (actual && ![actual isKindOfClass:[NSString class]])
        [NSException WOTest_raise:WO_TEST_CLASS_MISMATCH_EXCEPTION
                           reason:WO_EXPECTED_STRING_EXCEPTION_REASON(actual)
                           inFile:path
                           atLine:line];
    if (![expected isKindOfClass:[NSString class]])
        [NSException WOTest_raise:WO_TEST_CLASS_MISMATCH_EXCEPTION
                           reason:WO_EXPECTED_STRING_EXCEPTION_REASON(expected)
                           inFile:path
                           atLine:line];
    BOOL result = actual ? (![actual hasPrefix:expected]) : NO;
    BOOL expectedTruncated, actualTruncated;
    [self writePassed:result
               inFile:path
               atLine:line
              message:@"expected prefix (not) \"%@\", got \"%@\"", WO_DESC(expected), WO_DESC(actual)];
    if (expectedTruncated)  _WOLog(@"expected result (not truncated): %@", WO_LONG_DESC(expected));
    if (actualTruncated)    _WOLog(@"actual result (not truncated): %@", WO_LONG_DESC(actual));
}

- (void)testString:(NSString *)actual hasSuffix:(NSString *)expected inFile:(char *)path atLine:(int)line
{
    if (!expected)
        [NSException WOTest_raise:WO_TEST_NIL_PARAMETER_EXCEPTION
                           reason:WO_NIL_PARAMETER_EXCEPTION_REASON
                           inFile:path
                           atLine:line];
    if (actual && ![actual isKindOfClass:[NSString class]])
        [NSException WOTest_raise:WO_TEST_CLASS_MISMATCH_EXCEPTION
                           reason:WO_EXPECTED_STRING_EXCEPTION_REASON(actual)
                           inFile:path
                           atLine:line];
    if (![expected isKindOfClass:[NSString class]])
        [NSException WOTest_raise:WO_TEST_CLASS_MISMATCH_EXCEPTION
                           reason:WO_EXPECTED_STRING_EXCEPTION_REASON(expected)
                           inFile:path
                           atLine:line];
    BOOL result = actual ? NO : [actual hasSuffix:expected];
    BOOL expectedTruncated, actualTruncated;
    [self writePassed:result
               inFile:path
               atLine:line
              message:@"expected suffix \"%@\", got \"%@\"", WO_DESC(expected), WO_DESC(actual)];
    if (expectedTruncated)  _WOLog(@"expected result (not truncated): %@", WO_LONG_DESC(expected));
    if (actualTruncated)    _WOLog(@"actual result (not truncated): %@", WO_LONG_DESC(actual));
}

- (void)testString:(NSString *)actual doesNotHaveSuffix:(NSString *)expected inFile:(char *)path atLine:(int)line
{
    if (!expected)
        [NSException WOTest_raise:WO_TEST_NIL_PARAMETER_EXCEPTION
                           reason:WO_NIL_PARAMETER_EXCEPTION_REASON
                           inFile:path
                           atLine:line];
    if (actual && ![actual isKindOfClass:[NSString class]])
        [NSException WOTest_raise:WO_TEST_CLASS_MISMATCH_EXCEPTION
                           reason:WO_EXPECTED_STRING_EXCEPTION_REASON(actual)
                           inFile:path
                           atLine:line];
    if (![expected isKindOfClass:[NSString class]])
        [NSException WOTest_raise:WO_TEST_CLASS_MISMATCH_EXCEPTION
                           reason:WO_EXPECTED_STRING_EXCEPTION_REASON(expected)
                           inFile:path
                           atLine:line];
    BOOL result = actual ? (![actual hasSuffix:expected]) : NO;
    BOOL expectedTruncated, actualTruncated;
    [self writePassed:result
               inFile:path
               atLine:line
              message:@"expected suffix (not) \"%@\", got \"%@\"", WO_DESC(expected), WO_DESC(actual)];
    if (expectedTruncated)  _WOLog(@"expected result (not truncated): %@", WO_LONG_DESC(expected));
    if (actualTruncated)    _WOLog(@"actual result (not truncated): %@", WO_LONG_DESC(actual));
}

- (void)testString:(NSString *)actual contains:(NSString *)expected inFile:(char *)path atLine:(int)line
{
    if (!expected)
        [NSException WOTest_raise:WO_TEST_NIL_PARAMETER_EXCEPTION
                           reason:WO_NIL_PARAMETER_EXCEPTION_REASON
                           inFile:path
                           atLine:line];
    if (actual && ![actual isKindOfClass:[NSString class]])
        [NSException WOTest_raise:WO_TEST_CLASS_MISMATCH_EXCEPTION
                           reason:WO_EXPECTED_STRING_EXCEPTION_REASON(actual)
                           inFile:path
                           atLine:line];
    if (![expected isKindOfClass:[NSString class]])
        [NSException WOTest_raise:WO_TEST_CLASS_MISMATCH_EXCEPTION
                           reason:WO_EXPECTED_STRING_EXCEPTION_REASON(expected)
                           inFile:path
                           atLine:line];
    BOOL result = actual ? NO : (!NSEqualRanges([actual rangeOfString:expected], NSMakeRange(NSNotFound, 0)));
    BOOL expectedTruncated, actualTruncated;
    [self writePassed:result
               inFile:path
               atLine:line
              message:@"expected contains \"%@\", got \"%@\"", WO_DESC(expected), WO_DESC(actual)];
    if (expectedTruncated)  _WOLog(@"expected result (not truncated): %@", WO_LONG_DESC(expected));
    if (actualTruncated)    _WOLog(@"actual result (not truncated): %@", WO_LONG_DESC(actual));
}

- (void)testString:(NSString *)actual doesNotContain:(NSString *)expected inFile:(char *)path atLine:(int)line
{
    if (!expected)
        [NSException WOTest_raise:WO_TEST_NIL_PARAMETER_EXCEPTION
                           reason:WO_NIL_PARAMETER_EXCEPTION_REASON
                           inFile:path
                           atLine:line];
    if (actual && ![actual isKindOfClass:[NSString class]])
        [NSException WOTest_raise:WO_TEST_CLASS_MISMATCH_EXCEPTION
                           reason:WO_EXPECTED_STRING_EXCEPTION_REASON(actual)
                           inFile:path
                           atLine:line];
    if (![expected isKindOfClass:[NSString class]])
        [NSException WOTest_raise:WO_TEST_CLASS_MISMATCH_EXCEPTION
                           reason:WO_EXPECTED_STRING_EXCEPTION_REASON(expected)
                           inFile:path
                           atLine:line];
    BOOL result = actual ? YES : (NSEqualRanges([actual rangeOfString:expected], NSMakeRange(NSNotFound, 0)));
    BOOL expectedTruncated, actualTruncated;
    [self writePassed:result
               inFile:path
               atLine:line
              message:@"expected contains (not) \"%@\", got \"%@\"", WO_DESC(expected), WO_DESC(actual)];
    if (expectedTruncated)  _WOLog(@"expected result (not truncated): %@", WO_LONG_DESC(expected));
    if (actualTruncated)    _WOLog(@"actual result (not truncated): %@", WO_LONG_DESC(actual));
}

#pragma mark -
#pragma mark NSArray test methods

- (void)testArray:(NSArray *)actual isEqualTo:(NSArray *)expected inFile:(char *)path atLine:(int)line
{
    if (actual && ![actual isKindOfClass:[NSArray class]])
        [NSException WOTest_raise:WO_TEST_CLASS_MISMATCH_EXCEPTION
                            reason:WO_EXPECTED_ARRAY_EXCEPTION_REASON(actual)
                            inFile:path
                            atLine:line];
    if (expected && ![expected isKindOfClass:[NSArray class]])
        [NSException WOTest_raise:WO_TEST_CLASS_MISMATCH_EXCEPTION
                            reason:WO_EXPECTED_ARRAY_EXCEPTION_REASON(expected)
                            inFile:path
                            atLine:line];
    BOOL equal = NO;
    if (!actual && !expected) equal = YES; // equal (both nil)
    else if (actual) equal = [actual isEqualToArray:expected];
    BOOL expectedTruncated, actualTruncated;
    [self writePassed:equal inFile:path atLine:line message:@"expected %@, got %@", WO_DESC(expected), WO_DESC(actual)];
    if (expectedTruncated)  _WOLog(@"expected result (not truncated): %@", WO_LONG_DESC(expected));
    if (actualTruncated)    _WOLog(@"actual result (not truncated): %@", WO_LONG_DESC(actual));
}

- (void)testArray:(NSArray *)actual isNotEqualTo:(NSArray *)expected inFile:(char *)path atLine:(int)line
{
    if (actual && ![actual isKindOfClass:[NSArray class]])
        [NSException WOTest_raise:WO_TEST_CLASS_MISMATCH_EXCEPTION
                            reason:WO_EXPECTED_ARRAY_EXCEPTION_REASON(actual)
                            inFile:path
                            atLine:line];
    if (expected && ![expected isKindOfClass:[NSArray class]])
        [NSException WOTest_raise:WO_TEST_CLASS_MISMATCH_EXCEPTION
                            reason:WO_EXPECTED_ARRAY_EXCEPTION_REASON(expected)
                            inFile:path
                            atLine:line];
    BOOL equal = NO;
    if (!actual && !expected) equal = YES; // equal (both nil)
    else if (actual) equal = [actual isEqualToArray:expected];
    BOOL expectedTruncated, actualTruncated;
    [self writePassed:(!equal) inFile:path atLine:line message:@"expected (not) %@, got %@", WO_DESC(expected), WO_DESC(actual)];
    if (expectedTruncated)  _WOLog(@"expected result (not truncated): %@", WO_LONG_DESC(expected));
    if (actualTruncated)    _WOLog(@"actual result (not truncated): %@", WO_LONG_DESC(actual));
}

#pragma mark -
#pragma mark NSDictionary test methods

- (void)testDictionary:(NSDictionary *)actual isEqualTo:(NSDictionary *)expected inFile:(char *)path atLine:(int)line
{
    if (actual && ![actual isKindOfClass:[NSArray class]])
        [NSException WOTest_raise:WO_TEST_CLASS_MISMATCH_EXCEPTION
                            reason:WO_EXPECTED_DICTIONARY_EXCEPTION_REASON(actual)
                            inFile:path
                            atLine:line];
    if (expected && ![expected isKindOfClass:[NSArray class]])
        [NSException WOTest_raise:WO_TEST_CLASS_MISMATCH_EXCEPTION
                            reason:WO_EXPECTED_DICTIONARY_EXCEPTION_REASON(expected)
                            inFile:path
                            atLine:line];
    BOOL equal = NO;
    if (!actual && !expected) equal = YES; // equal (both nil)
    else if (actual) equal = [actual isEqualToDictionary:expected];
    BOOL expectedTruncated, actualTruncated;
    [self writePassed:equal inFile:path atLine:line message:@"expected %@, got %@", WO_DESC(expected), WO_DESC(actual)];
    if (expectedTruncated)  _WOLog(@"expected result (not truncated): %@", WO_LONG_DESC(expected));
    if (actualTruncated)    _WOLog(@"actual result (not truncated): %@", WO_LONG_DESC(actual));
}

- (void)testDictionary:(NSDictionary *)actual isNotEqualTo:(NSDictionary *)expected inFile:(char *)path atLine:(int)line
{
    if (actual && ![actual isKindOfClass:[NSDictionary class]])
        [NSException WOTest_raise:WO_TEST_CLASS_MISMATCH_EXCEPTION
                            reason:WO_EXPECTED_DICTIONARY_EXCEPTION_REASON(actual)
                            inFile:path
                            atLine:line];
    if (expected && ![expected isKindOfClass:[NSDictionary class]])
        [NSException WOTest_raise:WO_TEST_CLASS_MISMATCH_EXCEPTION
                            reason:WO_EXPECTED_DICTIONARY_EXCEPTION_REASON(expected)
                            inFile:path
                            atLine:line];
    BOOL equal = NO;
    if (!actual && !expected) equal = YES; // equal (both nil)
    else if (actual) equal = [actual isEqualToDictionary:expected];
    BOOL expectedTruncated, actualTruncated;
    [self writePassed:(!equal) inFile:path atLine:line message:@"expected (not) %@, got %@", WO_DESC(expected), WO_DESC(actual)];
    if (expectedTruncated)  _WOLog(@"expected result (not truncated): %@", WO_LONG_DESC(expected));
    if (actualTruncated)    _WOLog(@"actual result (not truncated): %@", WO_LONG_DESC(actual));
}

#pragma mark -
#pragma mark Exception test methods

- (void)testThrowsException:(id)exception inFile:(char *)path atLine:(int)line
{
    BOOL result = (exception ? YES : NO);
    [self writePassed:result
               inFile:path
               atLine:line
              message:[NSString stringWithFormat:@"expected exception, got %@", [NSException WOTest_nameForException:exception]]];
}

- (void)testDoesNotThrowException:(id)exception inFile:(char *)path atLine:(int)line
{
    BOOL result = (exception ? NO : YES);
    [self writePassed:result
               inFile:path
               atLine:line
              message:
        [NSString stringWithFormat:@"expected no exception, got %@", [NSException WOTest_nameForException:exception]]];
}

- (void)testThrowsException:(id)exception named:(NSString *)name inFile:(char *)path atLine:(int)line
{
    if (name && ![name isKindOfClass:[NSString class]])
    {
        [NSException WOTest_raise:WO_TEST_CLASS_MISMATCH_EXCEPTION
                           reason:WO_EXPECTED_STRING_EXCEPTION_REASON(name)
                           inFile:path
                           atLine:line];
    }

    BOOL        result      = NO;
    NSString    *actualName = [NSException WOTest_nameForException:exception];

    if (exception && [actualName isEqualToString:name]) result = YES;

    [self writePassed:result
               inFile:path
               atLine:line
              message:[NSString stringWithFormat:@"expected %@, got %@", name, actualName]];
}

- (void)testDoesNotThrowException:(id)exception named:(NSString *)name inFile:(char *)path atLine:(int)line
{
    if (name && ![name isKindOfClass:[NSString class]])
    {
        [NSException WOTest_raise:WO_TEST_CLASS_MISMATCH_EXCEPTION
                           reason:WO_EXPECTED_STRING_EXCEPTION_REASON(name)
                           inFile:path
                           atLine:line];
    }

    BOOL        result      = YES;
    NSString    *actualName = [NSException WOTest_nameForException:exception];

    if (exception && [actualName isEqualToString:name]) result = NO;

    [self writePassed:result inFile:path atLine:line message:@"expected (not) %@, got %@", name, actualName];
}

#pragma mark -
#pragma mark Random value generator methods

// TODO: move these into a category, these are more "test helpers" rather than actual "testing methods"

- (int)anInt
{
    return (int)(WO_RANDOM_SIGN * (WO_TEST_VALUE + (WO_RANDOM_OFFSET * WO_RANDOM_SIGN)));
}

- (int)aPositiveInt
{
    return (int)(WO_TEST_VALUE + (WO_RANDOM_OFFSET * WO_RANDOM_SIGN));
}

- (int)aNegativeInt
{
    return (int)-(WO_TEST_VALUE + (WO_RANDOM_OFFSET * WO_RANDOM_SIGN));
}

- (int)aZeroInt
{
    return 0;
}

- (int)aBigInt
{
    return (int)(WO_RANDOM_SIGN * (WO_BIG_TEST_VALUE + (WO_RANDOM_OFFSET * WO_RANDOM_SIGN)));
}

- (int)aBigPositiveInt
{
    return (int)(WO_BIG_TEST_VALUE + (WO_RANDOM_OFFSET * WO_RANDOM_SIGN));
}

- (int)aBigNegativeInt
{
    return (int)-(WO_BIG_TEST_VALUE + (WO_RANDOM_OFFSET * WO_RANDOM_SIGN));
}

- (int)aSmallInt
{
    return (int)(WO_RANDOM_SIGN * (WO_SMALL_TEST_VALUE + (WO_RANDOM_OFFSET * WO_RANDOM_SIGN)));
}

- (int)aSmallPositiveInt
{
    return (int)(WO_SMALL_TEST_VALUE + (WO_RANDOM_OFFSET * WO_RANDOM_SIGN));
}

- (int)aSmallNegativeInt
{
    return (int)-(WO_SMALL_TEST_VALUE + (WO_RANDOM_OFFSET * WO_RANDOM_SIGN));
}

- (unsigned)anUnsigned
{
    return (unsigned)(WO_TEST_VALUE + (WO_RANDOM_OFFSET * WO_RANDOM_SIGN));
}

- (unsigned)aZeroUnsigned
{
    return 0;
}

- (unsigned)aBigUnsigned
{
    return (unsigned)(WO_BIG_TEST_VALUE + (WO_RANDOM_OFFSET * WO_RANDOM_SIGN));
}

- (unsigned)aSmallUnsigned
{
    return (unsigned)(WO_SMALL_TEST_VALUE + (WO_RANDOM_OFFSET * WO_RANDOM_SIGN));
}

- (float)aFloat
{
    return (float)(WO_RANDOM_SIGN * (WO_TEST_VALUE + (WO_RANDOM_OFFSET * WO_RANDOM_SIGN)));
}

- (float)aPositiveFloat
{
    return (float)(WO_TEST_VALUE + (WO_RANDOM_OFFSET * WO_RANDOM_SIGN));
}

- (float)aNegativeFloat
{
    return (float)-(WO_TEST_VALUE + (WO_RANDOM_OFFSET * WO_RANDOM_SIGN));
}

- (float)aZeroFloat
{
    return 0.0;
}

- (float)aBigFloat
{
    return (float)(WO_RANDOM_SIGN * (WO_BIG_TEST_VALUE + (WO_RANDOM_OFFSET * WO_RANDOM_SIGN)));
}

- (float)aBigPositiveFloat
{
    return (float)(WO_BIG_TEST_VALUE + (WO_RANDOM_OFFSET * WO_RANDOM_SIGN));
}

- (float)aBigNegativeFloat
{
    return (float)-(WO_BIG_TEST_VALUE + (WO_RANDOM_OFFSET * WO_RANDOM_SIGN));
}

- (float)aSmallFloat
{
    return (float)(WO_RANDOM_SIGN * (WO_SMALL_TEST_VALUE + (WO_RANDOM_OFFSET * WO_RANDOM_SIGN)));
}

- (float)aSmallPositiveFloat
{
    return (float)(WO_SMALL_TEST_VALUE + (WO_RANDOM_OFFSET * WO_RANDOM_SIGN));
}

- (float)aSmallNegativeFloat
{
    return (float)-(WO_SMALL_TEST_VALUE + (WO_RANDOM_OFFSET * WO_RANDOM_SIGN));
}

- (double)aDouble
{
    return (double)(WO_RANDOM_SIGN * (WO_TEST_VALUE + (WO_RANDOM_OFFSET * WO_RANDOM_SIGN)));
}

- (double)aPositiveDouble
{
    return (double)(WO_TEST_VALUE + (WO_RANDOM_OFFSET * WO_RANDOM_SIGN));
}

- (double)aNegativeDouble
{
    return (double)-(WO_TEST_VALUE + (WO_RANDOM_OFFSET * WO_RANDOM_SIGN));
}

- (double)aZeroDouble
{
    return 0.0;
}

- (double)aBigDouble
{
    return (double)(WO_RANDOM_SIGN * (WO_BIG_TEST_VALUE + (WO_RANDOM_OFFSET * WO_RANDOM_SIGN)));
}

- (double)aBigPositiveDouble
{
    return (double)(WO_BIG_TEST_VALUE + (WO_RANDOM_OFFSET * WO_RANDOM_SIGN));
}

- (double)aBigNegativeDouble
{
    return (double)-(WO_BIG_TEST_VALUE + (WO_RANDOM_OFFSET * WO_RANDOM_SIGN));
}

- (double)aSmallDouble
{
    return (double)(WO_RANDOM_SIGN * (WO_SMALL_TEST_VALUE + (WO_RANDOM_OFFSET * WO_RANDOM_SIGN)));
}

- (double)aSmallPositiveDouble
{
    return (double)(WO_SMALL_TEST_VALUE + (WO_RANDOM_OFFSET * WO_RANDOM_SIGN));
}

- (double)aSmallNegativeDouble
{
    return (double)-(WO_SMALL_TEST_VALUE + (WO_RANDOM_OFFSET * WO_RANDOM_SIGN));
}

#pragma mark -
#pragma mark Properties

@synthesize startDate;
@synthesize testsRun;
@synthesize testsPassed;
@synthesize testsFailed;
@synthesize uncaughtExceptions;
@synthesize testsFailedExpected;
@synthesize testsPassedUnexpected;
@synthesize expectFailures;
@synthesize lowLevelExceptionsExpected;
@synthesize lowLevelExceptionsUnexpected;
@synthesize expectLowLevelExceptions;
@synthesize verbosity;
@synthesize trimInitialPathComponents;
@synthesize lastReportedFile;
@synthesize lastReportedLine;
@synthesize warnsAboutSignComparisons;

@end
